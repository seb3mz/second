1. 用例设计和用例分析有什么区别和联系?
    用例设计是用例分析的延续,通过利用架构设计提供的素材(设计元素和设计机制等),
    在不同的局部,将分析的结果用设计元素加以替换和实现
    用例设计所采用的建模方法与用例分析完全相同,主要还是交互图分析动态场景、类图
    描述静态结构.但是,其出发点和关注点则完全不同;从出发点上来说,不再使用分析类的
    概念分配职责,而是从设计元素、设计机制的角度,结合设计原则和模式(包括 GoF 模式
    和职责分配模式)进行职责分配;从关注点来说,用例设计关注的是职责如何实现而不是目
    标类需要提供什么职责,即目标类提供怎样的操作才可以响应这些消息,这意味着发送到设
    计类的消息对应设计类的操作,而发送到子系统的消息对应其接口的操作

2. 什么情况下可以将用例事件流中的交互封装位独立的子系统,封装之后有什么好处?
    当出现以下情况时,可以考虑把交互图中的子流封装成独立的子系统
    1) 子流在不同的用例实现中重复出现.也就是说,相同(或相似)的消息发送给相同
    (或相似)的对象,产生相同的最终结果
    2) 子流只在一个用例实现中出现,但期望在后期的迭代或者后续相似系统中扩展或
    复用
    3) 子流只在一个用例实现中出现,相对比复杂但却很容易被封装,它需要独立人或
    者团队单独设计并实现,并且有明确的输入或输出.在这种情况下,复杂行为通常要求
    具备专门的技术或领域知识,因此适合将其封装在子系统中独立设计实现
    4) 被封装在单独的构件中实现的子流,比如某些业务确定采用第三方构件来来实现
    利用子系统封装交互有效地提高了用例实现事件流的抽象级别,从而使得用例实现的
    结构相对比较清楚,较少混乱,尤其针对在那些非常复杂的交互而言.同时,这种方式
    可以在完成子系统内部设计之前可以创建用例实现,以利于并型开发.此外,封装使得
    用例实现变得更加通用,也更容易适应变更,因为子系统是可替换的,只要保持接口不变

3. 什么是子系统的代理类,子系统的接口和代理类有何区别和联系?
    在子系统设计时,为了便于在交互图中描述子系统,可以为每个子系统定义特定的代理
    类,其操作即为子系统的职责.与接口不同的是,代理类在子系统内部,对外代表特定的
    子系统;而接口在子系统外面,代表所有实现该接口的子系统

4. 子系统设计主要包括哪些工作?
    针对每一个待设计的子系统,需要完成以下三个方面的工作
    1) 将子系统行为分配给子系统元素:一个子系统对外提供的行为完全由其接口进行
    描述,因此接口操作的集合代表子系统的职责.子系统设计的第一步就是针对接口所描述的
    每一个操作进行设计,通过交互图将操作的职责分配给子系统内部的设计元素
    2) 描述子系统内部的设计元素:在交互图的基础上,定义每个设计元素的结构和关系,
    完成子系统内部设计模型
    3) 定义子系统间的依赖关系:分析子系统与外部设计元素之间的依赖关系,明确子系统
    之间的耦合,以便于子系统的复用

5. 在类设计阶段,针对三种分析类有什么不同的设计策略?
    1) 边界类的设计策略:边界类分为用户界面和系统接口,其中系统接口在架构设计时一般定义
    为子系统和接口来实现,并通过子系统设计来完成其内部设计流程.而针对用户界面类,需要
    研究具体的与用户交互的场景,设计满足要求的最终用户界面.界面类的设计往往依赖项目
    可用的用户界面开发工具.目前大多数界面设计工具都提供了自动创建了实现用户节目所
    必须的支持类的能力,这样类设计期间并不需要太多的考虑.更多地是从界面元素的布局等
    人机工程学方面去考虑问题.
    2) 实体类的设计策略:由于实体类本身职责的明确性,大多数实体类都可以直接作为初始的设计
    类存在.不过由于实体类往往具有持久性架构机制,因此该架构机制应用以及数据库的一些
    设计原则也会影响到实体类的设计方案.此外,性能方面的要求也可能要求对实体类进行重构
    3) 控制类的设计策略:控制类的设计首先需要明确该控制类是否有必要存在,有些控制类只是简
    单地将边界类的消息转发给实体类,这种不含任何业务逻辑或处理流程的控制类就没有存在的
    必要.当决定保留现有的控制类实现用例行为时,需要结合当前的用例实现和设计质量方面的
    考虑,针对现有的控制类进行适当的处理，可以从以下两个方面改进控制类:1.提供公共控制类
    2.分解复杂的控制类

6. 什么是操作和属性的可见性,有哪几种可见性?
    可见性是指操作或属性可以被外界访问的程度.UML规范定义了四种可见性:公有、私有、保护
    和包可见性

7. 什么是类的操作,什么是类的方法,它们有何区别和联系?
    操作是类的行为特征,它描述了该类对于特定请求作出应答的规范
    方法是操作的具体实现算法,它描述操作如何实现的流程.
    操作描述了类对外提供的接口,是类的外在行为.通过定义操作明确了参数和返回值等接口细节;
    而方法则是关注操作内部实现算法的设计

8. 什么情况下需要进行类的状态建模,如何进行状态建模?
    在类设计期间,针对那些受状态影响的对象进行状态建模,从而可以描述该对象所能能够响应的
    事件、对这些事件的响应以及过去对当前行为的影响等方面的问题
    状态建模过程需要从几个方面展开:
        1) 哪些对象有重要的状态,需要进行状态建模;
        2) 针对需要进行状态建模的对象,如何确定该对象可能的状态;并分析状态之间的转移,
        完成状态机模型
        3) 如何将状态模型中的状态和事件信息映射到模型的其他部分

9. 什么是关联的导航性,如何设计导航性?
    导航性是指关联的方向,它描述了从源类的任何对象到目标类的一个或多个对象的访问权限,
    消息仅能在箭头的方向上传递
    在分析阶段,没有描述导航性则默认为双向的导航.而设计阶段,则应根据需要设计单方向的
    导航性.好的面向对象设计的目标是最小化类间的耦合,而使用单方向的导航性可以降低耦合,
    在没有导航性的方向上就没有类间的耦合,实现时也不需要额外的支持.此外,双方向关联难
    以实现,需要消耗额外的维护成本.这些因素都表明,在设计期间应尽可能采用单方向的关联.
    当类A与类B关联时,应从类A(或类B)对象是否需要知道类B(或类A)的对象来入手来分析它们
    之间的导航性;换个角度来说,即从类A(或类B)对象是否向类B(或类A)的对象发送消息

10. 什么是类间的组合关系,和聚合关系有何区别和联系?
    组合关系是一种特殊的聚合关系,在整体拥有部分同时,部分不能脱离整体而存在;当整体不存
    在时,部分也没有存在的意义.从实现角度来说,聚合表示一种引用关联,即整体保存部分的引
    用,部分本身可以相对独立的存在;而组合则表示一种指关联,整体直接拥有部分的值,并负责
    部分的创建和删除

11. 什么是类间的依赖关系,哪些情况下定义为依赖关系?
    依赖是一种使用关系,表示一个类对象使用另一个类对象的信息和服务,被使用对象的变化可能
    会影响到使用对象
    定义为依赖关系的集中情况:参数引用、局部声明引用和全局引用

12. 类间的泛化关系有什么优点和缺点?
    优点:通过使用泛化关系可以实现代码的复用和多态的支持
    缺点:
        1) 类间可能耦合的最强形式:子类会继承父类所有的属性、方法和关系
        2) 类层次中的封装是脆弱的:父类的改动会直接涉及所有下层的所有子类
        3) 在大多数语言中,继承是不能轻易改变:这种泛化关系是在编译时确定的,运行时是固定
        的,不能改变

13. 面向对象的设计中,数据库设计阶段需要考虑哪些问题?
    数据库设计主要包括以下几个方面的工作:
    1) 确定设计中需要存储的持久性类:这部分工作在前面的分析和设计中已同步开展,通过持久性
    架构机制对持久化类进行了说明
    2) 设计适当的数据库结构以存储持久化类:数据库设计阶段的核心内容,需要根据已有的对象模
    型设计对应的数据模型(实体关系模型)
    3) 为存储和访问持久化数据定义机制和策略,以满足系统的性能要求:遵循架构设计中的相关设
    计机制的所提出的策略,实现数据的存储和访问

14. 如何将对象模型映射为数据模型?
    可以利用一定的映射规则从对象模型中直接构造数据模型,从而简化数据建模过程,主要的规则
    包括:
    1) 映射类和属性:把每个需要持久化的实体类映射为一张表,持久化属性对应表中的字段:类的
    对象对应表中的记录
    2) 映射关联关系:类之间的关联关系在数据模型中通过主外键的约束来表达,根据多重性的不同,
    有不同的映射规则
    3) 映射泛化关系:数据模型没有提供泛化关系的直接实现机制,可以采用不同的设计方案来实现
    泛化关系
